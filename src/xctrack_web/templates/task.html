<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XCTrack Task: {{ task_code }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .task-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 0;
            margin-bottom: 30px;
        }

        .task-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .turnpoint-table {
            font-size: 0.9rem;
        }

        .map-container {
            height: 500px;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .qr-code-container {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stats-card {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .info-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .loading {
            text-align: center;
            padding: 40px;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .btn-download {
            margin: 5px;
        }

        .badge-custom {
            font-size: 0.8em;
            padding: 0.5em 0.8em;
        }

        .route-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 200px;
        }

        .route-loading .spinner-border {
            width: 2rem;
            height: 2rem;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">
                <i class="fas fa-parachute-box"></i>
                <strong>XCTrack Task Analysis</strong>
            </a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="/">
                    <i class="fas fa-home"></i> Home
                </a>
            </div>
        </div>
    </nav>

    <div class="task-header">
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1><i class="fas fa-map-marked-alt"></i> XCTrack Competition Task</h1>
                    <p class="lead mb-0">Task Code: <code>{{ task_code }}</code></p>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div id="loading" class="loading">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h4 class="mt-3">Processing Task</h4>
            <div class="mt-4">
                <div class="list-group" id="processingSteps">
                    <!-- Processing steps will be added dynamically -->
                </div>
            </div>
        </div>

        <div id="error" class="error" style="display: none;">
            <h4><i class="fas fa-exclamation-triangle"></i> Error</h4>
            <p id="errorMessage"></p>
        </div>

        <div id="taskContent" style="display: none;">
            <!-- Task content will be loaded here -->
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const taskCode = '{{ task_code }}';
        let currentTaskData = null;

        // Load task data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadTaskData();
        });

        function loadTaskData() {
            // First check if data is fully cached
            fetch(`/api/task/${taskCode}/cache-status`)
                .then(response => response.json())
                .then(cacheStatus => {
                    if (cacheStatus.fully_cached) {
                        // Data is cached, load directly without showing loading screen
                        document.getElementById('loading').style.display = 'none';
                        loadTaskDataDirect();
                    } else {
                        // Data needs processing, show loading screen with progress
                        loadTaskDataWithProgress();
                    }
                })
                .catch(error => {
                    console.warn('Cache status check failed, proceeding with loading screen:', error);
                    // Fallback to showing loading screen
                    loadTaskDataWithProgress();
                });
        }

        function loadTaskDataDirect() {
            // Load task data directly without progress tracking
            fetch(`/api/task/${taskCode}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(data.error);
                    } else {
                        currentTaskData = data;
                        displayTask(data);
                    }
                })
                .catch(error => {
                    showError('Failed to load task data: ' + error.message);
                });
        }

        function loadTaskDataWithProgress() {
            let progressInterval;

            // Clear existing steps and prepare for dynamic loading
            clearProcessingSteps();

            // Start polling for progress updates
            progressInterval = setInterval(() => {
                fetch(`/api/task/${taskCode}/progress`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.message && data.progress !== undefined) {
                            updateLoadingStatus(data.message, data.progress, data.details);
                        }
                    })
                    .catch(error => {
                        console.warn('Progress update failed:', error);
                    });
            }, 500);

            // Start the actual task loading
            fetch(`/api/task/${taskCode}`)
                .then(response => {
                    return response.json();
                })
                .then(data => {
                    clearInterval(progressInterval);

                    // Create and show final completion step
                    const finalStepData = { text: 'Task processing complete', icon: 'fas fa-check-circle' };
                    createStepIfNotExists('step-complete', finalStepData);

                    // Complete all previous steps and show final completion
                    completePreviousSteps('step-complete');
                    completeStep('step-complete', 'Task loaded successfully');

                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';

                        if (data.error) {
                            showError(data.error);
                        } else {
                            currentTaskData = data;
                            displayTask(data);
                        }
                    }, 1000); // Show completion for 1 second before hiding
                })
                .catch(error => {
                    clearInterval(progressInterval);
                    document.getElementById('loading').style.display = 'none';
                    showError('Failed to load task data: ' + error.message);
                });
        }

        function updateLoadingStatus(message, progress = null, details = null) {
            // Create or update step based on message content
            let stepId = getStepIdFromMessage(message);
            let stepData = getStepDataFromMessage(message);

            if (stepId && stepData) {
                // Create the step if it doesn't exist
                createStepIfNotExists(stepId, stepData);

                // Show current step as in progress
                showStep(stepId, message);

                // Complete previous steps if any
                completePreviousSteps(stepId);
            }
        }

        function getStepIdFromMessage(message) {
            // Map messages to step IDs based on backend progress messages
            if (message.includes('Loading task file') || message.includes('Loading task for route')) {
                return 'step-loading';
            } else if (message.includes('Parsing task data') || message.includes('Reading and validating')) {
                return 'step-parsing';
            } else if (message.includes('Converting to web format') || message.includes('Preparing task')) {
                return 'step-converting';
            } else if (message.includes('Calculating distances') || message.includes('Preparing route calculation') || message.includes('Calculating route coordinates')) {
                return 'step-distances';
            } else if (message.includes('Optimizing route') || message.includes('Calculating optimized')) {
                return 'step-route';
            } else if (message.includes('Checking for SSS') || message.includes('Finalizing route') || message.includes('Adding route data')) {
                return 'step-finalizing';
            } else if (message.includes('Complete') || message.includes('successfully') || message.includes('processing complete')) {
                return 'step-complete';
            }
            return null;
        }

        function getStepDataFromMessage(message) {
            // Get step display information based on message
            const stepData = {
                'step-loading': { text: 'Loading task data', icon: 'fas fa-download' },
                'step-parsing': { text: 'Parsing task data', icon: 'fas fa-file-alt' },
                'step-converting': { text: 'Converting to web format', icon: 'fas fa-exchange-alt' },
                'step-distances': { text: 'Calculating distances', icon: 'fas fa-ruler' },
                'step-route': { text: 'Optimizing route', icon: 'fas fa-route' },
                'step-finalizing': { text: 'Finalizing task data', icon: 'fas fa-cogs' },
                'step-complete': { text: 'Task processing complete', icon: 'fas fa-check-circle' }
            };

            const stepId = getStepIdFromMessage(message);
            return stepId ? stepData[stepId] : null;
        }

        function createStepIfNotExists(stepId, stepData) {
            if (!document.getElementById(stepId)) {
                const stepsContainer = document.getElementById('processingSteps');
                const stepElement = document.createElement('div');
                stepElement.className = 'list-group-item d-flex justify-content-between align-items-center';
                stepElement.id = stepId;
                stepElement.innerHTML = `
                    <span><i class="${stepData.icon} text-secondary me-2"></i>${stepData.text}...</span>
                    <span class="badge bg-secondary rounded-pill">Waiting</span>
                `;
                stepsContainer.appendChild(stepElement);
            }
        }

        function completePreviousSteps(currentStepId) {
            // Define step order
            const stepOrder = ['step-loading', 'step-parsing', 'step-converting', 'step-distances', 'step-route', 'step-finalizing', 'step-complete'];
            const currentIndex = stepOrder.indexOf(currentStepId);

            // Complete all previous steps
            for (let i = 0; i < currentIndex; i++) {
                const stepElement = document.getElementById(stepOrder[i]);
                if (stepElement) {
                    completeStep(stepOrder[i]);
                }
            }
        }

        function showStep(stepId, message = null) {
            const step = document.getElementById(stepId);
            if (step) {
                step.style.display = 'block';

                const icon = step.querySelector('i');
                const badge = step.querySelector('.badge');
                const textSpan = step.querySelector('span');

                // Update icon to spinning
                icon.className = icon.className.replace('text-secondary', 'text-primary').replace('fa-check-circle', 'fa-circle-notch fa-spin');

                // Update badge to "In Progress"
                badge.textContent = 'In Progress';
                badge.className = 'badge bg-primary rounded-pill';

                // Update message if provided
                if (message) {
                    const iconClass = icon.className;
                    textSpan.innerHTML = `<i class="${iconClass}"></i>${message}`;
                }
            }
        }

        function completeStep(stepId, message = null) {
            const step = document.getElementById(stepId);
            if (step) {
                const icon = step.querySelector('i');
                const badge = step.querySelector('.badge');
                const textSpan = step.querySelector('span');

                // Update icon to check mark
                const baseIconClass = icon.className.replace('fa-circle-notch fa-spin text-primary', 'fa-check-circle text-success').replace('text-secondary', 'text-success');
                icon.className = 'fas fa-check-circle text-success me-2';

                // Update badge to "Done"
                badge.textContent = 'Done';
                badge.className = 'badge bg-success rounded-pill';

                // Update message if provided - keep original text but with check icon
                if (message) {
                    textSpan.innerHTML = `<i class="fas fa-check-circle text-success me-2"></i>${message}`;
                } else {
                    // Just update the icon, keep existing text
                    const currentText = textSpan.textContent || textSpan.innerText;
                    textSpan.innerHTML = `<i class="fas fa-check-circle text-success me-2"></i>${currentText}`;
                }
            }
        }

        function clearProcessingSteps() {
            // Clear all dynamically created steps
            const stepsContainer = document.getElementById('processingSteps');
            stepsContainer.innerHTML = '';
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('error').style.display = 'block';
        }

        function displayTask(task) {
            const html = generateTaskHTML(task);
            document.getElementById('taskContent').innerHTML = html;
            document.getElementById('taskContent').style.display = 'block';

            // Initialize map
            if (task.turnpoints.length > 0) {
                initializeMap(task.turnpoints);
            }
        }

        function generateTaskHTML(task) {
            return `
                <div class="row">
                    <div class="col-md-8">
                        <div class="info-card">
                            <h2><i class="fas fa-info-circle text-primary"></i> Task Information</h2>
                            <div class="row">
                                <div class="col-md-6">
                                    <p><strong><i class="fas fa-tag"></i> Task Type:</strong> ${task.taskType}</p>
                                    <p><strong><i class="fas fa-code-branch"></i> Version:</strong> ${task.version}</p>
                                    <p><strong><i class="fas fa-globe"></i> Earth Model:</strong> ${task.earthModel || 'Not specified'}</p>
                                </div>
                                <div class="col-md-6">
                                    ${task.takeoff ? `
                                        <p><strong><i class="fas fa-play-circle text-success"></i> Take-off Open:</strong> ${task.takeoff.timeOpen || 'Not specified'}</p>
                                        <p><strong><i class="fas fa-stop-circle text-danger"></i> Take-off Close:</strong> ${task.takeoff.timeClose || 'Not specified'}</p>
                                    ` : ''}
                                    ${task.sss ? `
                                        <p><strong><i class="fas fa-flag text-primary"></i> SSS Open:</strong> ${task.sss.timeGates.join(', ') || 'Not specified'}</p>
                                        <p><strong><i class="fas fa-racing-flag"></i> Start Type:</strong> ${task.sss.type}</p>
                                    ` : ''}
                                    ${task.goal ? `
                                        <p><strong><i class="fas fa-bullseye text-warning"></i> Goal Type:</strong> ${task.goal.type || 'Not specified'}</p>
                                        <p><strong><i class="fas fa-clock text-danger"></i> Task Deadline:</strong> ${task.goal.deadline || 'Not specified'}</p>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="stats-card">
                            <i class="fas fa-chart-line fa-2x mb-3"></i>
                            <h3>Task Statistics</h3>
                            <div class="h3 mb-1">${task.stats.totalDistance} km</div>
                            <p class="mb-2">Distance (centers)</p>
                            <div class="h4 mb-1">${task.stats.totalOptimizedDistance} km</div>
                            <p class="mb-3">Optimized distance</p>
                            <div class="h5 mb-1">${task.stats.turnpointCount}</div>
                            <p class="mb-0">Turnpoints</p>
                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12">
                        <div class="info-card">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h3><i class="fas fa-map text-primary"></i> Task Map</h3>
                                <div class="btn-group" role="group" aria-label="Route display options">

                                    <input type="radio" class="btn-check" name="routeToggle" id="optimizedRoute" checked>
                                    <label class="btn btn-outline-success btn-sm" for="optimizedRoute">
                                        <i class="fas fa-route"></i> Optimized Route
                                    </label>

                                    <input type="radio" class="btn-check" name="routeToggle" id="centerRoute">
                                    <label class="btn btn-outline-primary btn-sm" for="centerRoute">
                                        <i class="fas fa-circle"></i> Center Route
                                    </label>
                                </div>
                            </div>
                            <div id="mapContainer" class="map-container" style="position: relative;">
                                <div id="routeLoading" class="route-loading" style="display: none;">
                                    <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <p class="mt-2 mb-0">Calculating optimized route...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12">
                        <div class="info-card">
                            <h3><i class="fas fa-list text-primary"></i> Turnpoints</h3>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover turnpoint-table">
                                    <thead class="table-dark">
                                        <tr>
                                            <th><i class="fas fa-hashtag"></i></th>
                                            <th><i class="fas fa-map-pin"></i> Name</th>
                                            <th><i class="fas fa-info"></i> Description</th>
                                            <th><i class="fas fa-circle-notch"></i> Radius (m)</th>
                                            <th><i class="fas fa-ruler"></i> Distance (km)</th>
                                            <th><i class="fas fa-route"></i> Optimized (km)</th>
                                            <th><i class="fas fa-tag"></i> Type</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${task.turnpoints.map(tp => `
                                            <tr>
                                                <td><strong>${tp.index + 1}</strong></td>
                                                <td><strong>${tp.name}</strong></td>
                                                <td>${tp.description}</td>
                                                <td>${tp.radius}</td>
                                                <td><strong>${tp.cumulative_center_km}</strong></td>
                                                <td><strong>${tp.cumulative_optimized_km}</strong></td>
                                                <td><span class="badge bg-${getTypeColor(tp.type)} badge-custom">${tp.type || 'Turnpoint'}</span></td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="qr-code-container">
                            <h3><i class="fas fa-qrcode text-primary"></i> QR Code</h3>
                            <p class="text-muted">Scan this code to XCTrack navigation</p>
                            <div id="qrCodeArea">
                                <button class="btn btn-primary" onclick="generateQRCode()">
                                    <i class="fas fa-qrcode"></i> Generate QR Code
                                </button>
                            </div>
                            <div id="qrCodeDisplay" style="display: none;">
                                <img id="qrCodeImage" class="img-fluid" style="max-width: 300px;">
                                <div class="mt-3">
                                    <small class="text-muted">Valid for 1 month • Task code: ${taskCode}</small>
                                </div>
                                <div class="mt-2">
                                    <textarea id="qrCodeString" class="form-control" rows="3" readonly style="font-size: 0.8em;"></textarea>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="info-card">
                            <h3><i class="fas fa-download text-primary"></i> Export Options</h3>
                            <p class="text-muted">Download task in different formats</p>
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary btn-download" onclick="downloadJSON()">
                                    <i class="fas fa-file-code"></i> Download as JSON
                                </button>
                                <button class="btn btn-outline-success btn-download" onclick="downloadKML()">
                                    <i class="fas fa-map"></i> Download as KML
                                </button>
                                <button class="btn btn-outline-info btn-download" onclick="copyTaskURL()">
                                    <i class="fas fa-link"></i> Copy Task URL
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function getTypeColor(type) {
            switch (type) {
                case 'TAKEOFF': return 'success';
                case 'SSS': return 'primary';
                case 'ESS': return 'warning';
                default: return 'secondary';
            }
        }

        function initializeMap(turnpoints) {
            // Calculate bounds
            const lats = turnpoints.map(tp => tp.lat);
            const lons = turnpoints.map(tp => tp.lon);
            const bounds = [
                [Math.min(...lats), Math.min(...lons)],
                [Math.max(...lats), Math.max(...lons)]
            ];

            // Initialize map
            const map = L.map('mapContainer').fitBounds(bounds, { padding: [20, 20] });

            // Add tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            // Store route layers for toggling
            let centerRouteLayer = null;
            let optimizedRouteLayer = null;
            let sssOptimalMarker = null;
            let sssConnectionLine = null;

            // Add turnpoint markers and circles
            turnpoints.forEach((tp, index) => {
                // Create custom icon based on type
                const iconColor = tp.type === 'TAKEOFF' ? 'green' :
                    tp.type === 'SSS' ? 'blue' :
                        tp.type === 'ESS' ? 'orange' : 'red';

                const marker = L.marker([tp.lat, tp.lon]).addTo(map);
                marker.bindPopup(`
                    <div style="min-width: 200px;">
                        <h6><strong>${tp.name}</strong></h6>
                        <p class="mb-1">${tp.description}</p>
                        <hr class="my-2">
                        <small>
                            <strong>Altitude:</strong> ${tp.alt}m<br>
                            <strong>Radius:</strong> ${tp.radius}m<br>
                            <strong>Coordinates:</strong> ${tp.lat.toFixed(6)}, ${tp.lon.toFixed(6)}<br>
                            ${tp.type ? `<strong>Type:</strong> ${tp.type}` : ''}
                        </small>
                    </div>
                `);

                // Add circle for turnpoint radius (scaled for visibility)
                const circleRadius = Math.max(tp.radius, 100); // Minimum 100m for visibility
                L.circle([tp.lat, tp.lon], {
                    radius: circleRadius,
                    fillColor: iconColor,
                    fillOpacity: 0.15,
                    color: iconColor,
                    weight: 2,
                    opacity: 0.6
                }).addTo(map);

                // Add turnpoint number
                L.marker([tp.lat, tp.lon], {
                    icon: L.divIcon({
                        className: 'turnpoint-label',
                        html: `<div style="background: white; border: 2px solid ${iconColor}; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px;">${index + 1}</div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(map);
            });

            // Draw center route (default)
            function drawCenterRoute() {
                if (centerRouteLayer) {
                    map.removeLayer(centerRouteLayer);
                }
                const taskLine = turnpoints.map(tp => [tp.lat, tp.lon]);
                centerRouteLayer = L.polyline(taskLine, {
                    color: '#dc3545',
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '10, 5'
                }).addTo(map);
            }

            // Draw optimized route
            function drawOptimizedRoute() {
                if (optimizedRouteLayer) {
                    map.removeLayer(optimizedRouteLayer);
                }

                // Show loading indicator and disable buttons
                document.getElementById('routeLoading').style.display = 'block';
                document.getElementById('optimizedRoute').disabled = true;
                document.getElementById('centerRoute').disabled = true;

                // Start progress polling for route calculation
                let routeProgressInterval = setInterval(() => {
                    fetch(`/api/task/${taskCode}/route-progress`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.message && data.progress !== undefined) {
                                const loadingDiv = document.getElementById('routeLoading');
                                const loadingText = loadingDiv.querySelector('p');
                                if (loadingText) {
                                    loadingText.textContent = data.message;
                                }
                                if (data.details) {
                                    loadingText.textContent += ` - ${data.details}`;
                                }
                            }
                        })
                        .catch(error => {
                            console.warn('Route progress update failed:', error);
                        });
                }, 500);

                // Fetch optimized route data
                fetch(`/api/task/${taskCode}/optimized-route`)
                    .then(response => response.json())
                    .then(data => {
                        clearInterval(routeProgressInterval);

                        // Hide loading indicator and re-enable buttons
                        document.getElementById('routeLoading').style.display = 'none';
                        document.getElementById('optimizedRoute').disabled = false;
                        document.getElementById('centerRoute').disabled = false;

                        if (data.error) {
                            console.error('Error fetching optimized route:', data.error);
                            alert('Error loading optimized route: ' + data.error);
                            // Switch back to center route
                            document.getElementById('centerRoute').checked = true;
                            showCenterRoute();
                        } else {
                            const routeCoords = data.route.map(pt => [pt.lat, pt.lon]);

                            // Check if this is an SSS task
                            if (data.sss_info && data.takeoff_center) {
                                // For SSS tasks, the routeCoords already contain the correct optimized route
                                // (takeoff center -> optimal points on turnpoints after SSS)
                                optimizedRouteLayer = L.polyline(routeCoords, {
                                    color: '#28a745',
                                    weight: 3,
                                    opacity: 0.9
                                }).addTo(map);

                                // Add a special marker for the optimal SSS entry point
                                const optimalSssPoint = [data.sss_info.optimal_entry_point.lat, data.sss_info.optimal_entry_point.lon];
                                sssOptimalMarker = L.marker(optimalSssPoint, {
                                    icon: L.divIcon({
                                        className: 'sss-optimal-point',
                                        html: '<div style="background: #007bff; border: 2px solid white; border-radius: 50%; width: 12px; height: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                        iconSize: [12, 12],
                                        iconAnchor: [6, 6]
                                    })
                                }).addTo(map).bindPopup('<strong>Optimal SSS Entry Point</strong><br>Best point to enter the Start Speed Section');

                                // Add a dashed line from takeoff to optimal SSS entry point to show the relation
                                const takeoffCoord = [data.takeoff_center.lat, data.takeoff_center.lon];
                                sssConnectionLine = L.polyline([takeoffCoord, optimalSssPoint], {
                                    color: '#007bff',
                                    weight: 2,
                                    opacity: 0.6,
                                    dashArray: '5, 5'
                                }).addTo(map);

                            } else {
                                // For non-SSS tasks, draw the normal optimized route
                                optimizedRouteLayer = L.polyline(routeCoords, {
                                    color: '#28a745',
                                    weight: 3,
                                    opacity: 0.9
                                }).addTo(map);
                            }
                        }
                    })
                    .catch(error => {
                        clearInterval(routeProgressInterval);

                        // Hide loading indicator and re-enable buttons
                        document.getElementById('routeLoading').style.display = 'none';
                        document.getElementById('optimizedRoute').disabled = false;
                        document.getElementById('centerRoute').disabled = false;

                        console.error('Error fetching optimized route:', error);
                        alert('Error loading optimized route: ' + error.message);
                        // Switch back to center route
                        document.getElementById('centerRoute').checked = true;
                        showCenterRoute();
                    });
            }

            // Route display functions
            function showCenterRoute() {
                // Hide loading indicator
                document.getElementById('routeLoading').style.display = 'none';

                if (optimizedRouteLayer) {
                    map.removeLayer(optimizedRouteLayer);
                }
                if (sssOptimalMarker) {
                    map.removeLayer(sssOptimalMarker);
                    sssOptimalMarker = null;
                }
                if (sssConnectionLine) {
                    map.removeLayer(sssConnectionLine);
                    sssConnectionLine = null;
                }
                drawCenterRoute();
            }

            function showOptimizedRoute() {
                if (centerRouteLayer) {
                    map.removeLayer(centerRouteLayer);
                }
                drawOptimizedRoute();
            }

            // Set up toggle event listeners
            document.getElementById('centerRoute').addEventListener('change', function () {
                if (this.checked) {
                    showCenterRoute();
                }
            });

            document.getElementById('optimizedRoute').addEventListener('change', function () {
                if (this.checked) {
                    showOptimizedRoute();
                }
            });

            // Initialize with optimized route (default)
            drawOptimizedRoute();

            // Store map reference for potential future use
            window.taskMap = map;
        }

        function generateQRCode() {
            const button = document.querySelector('#qrCodeArea button');
            button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
            button.disabled = true;

            fetch(`/api/task/${taskCode}/qr`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert('Error generating QR code: ' + data.error);
                    } else {
                        document.getElementById('qrCodeImage').src = data.qr_code;
                        document.getElementById('qrCodeString').value = data.qr_string;
                        document.getElementById('qrCodeArea').style.display = 'none';
                        document.getElementById('qrCodeDisplay').style.display = 'block';
                    }
                })
                .catch(error => {
                    alert('Error generating QR code: ' + error.message);
                })
                .finally(() => {
                    button.innerHTML = '<i class="fas fa-qrcode"></i> Generate QR Code';
                    button.disabled = false;
                });
        }

        function downloadJSON() {
            if (currentTaskData) {
                const dataStr = JSON.stringify(currentTaskData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `task_${taskCode}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }
        }

        function downloadKML() {
            alert('KML download functionality to be implemented');
        }

        function copyTaskURL() {
            const url = window.location.href;
            navigator.clipboard.writeText(url).then(() => {
                // Show temporary success message
                const button = event.target;
                const originalText = button.innerHTML;
                button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                button.classList.remove('btn-outline-info');
                button.classList.add('btn-success');
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.classList.remove('btn-success');
                    button.classList.add('btn-outline-info');
                }, 2000);
            }).catch(() => {
                alert('Failed to copy URL to clipboard');
            });
        }
    </script>
</body>

</html>